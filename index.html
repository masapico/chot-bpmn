<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Flow Canvas</title>
    <link
      rel="icon"
      href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><rect width=%22100%22 height=%22100%22 fill=%22%23f0f0f0%22 rx=%2220%22 ry=%2220%22></rect><circle cx=%2230%22 cy=%2250%22 r=%2215%22 fill=%22%23007bff%22></circle><polygon points=%2250,40 50,60 70,50%22 fill=%22%2328a745%22></polygon><rect x=%2275%22 y=%2235%22 width=%2230%22 height=%2230%22 fill=%22%23ffc107%22 rx=%225%22 ry=%225%22 transform=%22translate(-15, 0)%22></rect></svg>"
    />

    <link rel="stylesheet" href="./lib/diagram-js.css" />
    <link rel="stylesheet" href="./lib/bpmn-embedded.css" />

    <link rel="stylesheet" href="./lib/bootstrap.min.css" />
    <style>
      /* 基本的なレイアウト */
      html,
      body {
        height: 100%;
        margin: 0;
        padding: 0;
        font-family: Arial, sans-serif;
        overflow: hidden; /* スクロールバーを隠す */
      }
      #bpmn-container {
        width: 100%;
        height: 100%;
        background-color: #e5e9ec;
        position: relative; /* djs-containerの親としてposition指定 */
      }
      /* フローティングボタンのコンテナ */
      .floating-buttons {
        position: fixed;
        bottom: 20px;
        left: 20px;
        right: auto;
        z-index: 100;
        background-color: #f0f0f0; /* Light grey background for the container */
        padding: 8px;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        display: flex; /* Horizontal layout for buttons */
        gap: 8px; /* Spacing between buttons */
      }
      .floating-buttons .btn {
        font-size: 1.2rem;
        width: 40px;
        height: 40px;
        padding: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        border: 1px solid #ccc;
        background-color: #fff;
        color: #333;
        border-radius: 6px;
      }
      .floating-buttons .btn:hover {
        background-color: #e9e9e9;
        border-color: #bbb;
      }

      .floating-buttons .btn svg {
        width: 20px;
        height: 20px;
      }

      /* エラーメッセージ */
      #error-message {
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background-color: rgba(
          220,
          53,
          69,
          0.9
        ); /* Bootstrap danger color with opacity */
        color: white;
        padding: 10px 20px;
        border-radius: 5px;
        z-index: 2000;
        display: none;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        font-size: 0.9rem;
      }
      #error-message .close-error {
        color: white;
        text-decoration: none;
        margin-left: 15px;
        font-weight: bold;
        cursor: pointer;
        float: right; /* 右寄せ */
        line-height: 1; /* 行の高さを調整 */
        padding: 0 5px;
      }

      /* パンくずリストのスタイル調整 */
      #bpmn-container .bjs-breadcrumbs {
        display: none; /* Initially hidden as per request ① */
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        background: #fafafa;
        border-bottom: solid 1px #ccc;
        padding: 6px 10px;
        list-style: none;
        margin: 0;
        z-index: 10;
        box-sizing: border-box;
        font-size: 13px;
        line-height: 1.4;
        text-align: center; /* 中央揃え */
      }

      #bpmn-container .bjs-breadcrumbs li {
        display: inline-flex;
        align-items: center;
        margin-right: 5px;
      }
      #bpmn-container .bjs-breadcrumbs li:not(:last-child)::after {
        content: ">";
        margin-left: 8px;
        margin-right: 3px;
        color: #555;
      }

      #bpmn-container .bjs-breadcrumbs li a,
      #bpmn-container .bjs-breadcrumbs li span.bjs-crumb {
        color: #333;
        text-decoration: none;
        display: inline-flex;
        align-items: center;
      }
      #bpmn-container .bjs-breadcrumbs li a:hover {
        color: #155cb5;
        text-decoration: underline;
      }
      #bpmn-container .bjs-breadcrumbs .bjs-crumb {
        font-size: 1rem;
      }

      /* エディタ背景のグリッドスタイル */
      #bpmn-container .djs-container .layer-djs-grid rect {
        fill: none;
      }
      #bpmn-container .djs-container {
        background-image: linear-gradient(
            to right,
            #e0e0e0 1px,
            transparent 1px
          ),
          linear-gradient(to bottom, #e0e0e0 1px, transparent 1px);
        background-size: 20px 20px;
      }

      .drop-active {
        outline: 2px dashed #007bff;
        outline-offset: -10px;
        background-color: rgba(0, 123, 255, 0.1);
      }

      /* Keyboard Shortcuts Modal Styles */
      .shortcuts-modal {
        display: none; /* Hidden by default */
        position: fixed;
        z-index: 1001; /* Above floating buttons */
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        overflow: auto;
        background-color: rgba(0, 0, 0, 0.4); /* Black w/ opacity */
      }

      .shortcuts-modal-content {
        background-color: #fefefe;
        margin: 10% auto; /* 10% from the top and centered */
        padding: 20px;
        border: 1px solid #888;
        width: 80%;
        max-width: 500px;
        border-radius: 8px;
        box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2),
          0 6px 20px 0 rgba(0, 0, 0, 0.19);
      }

      .shortcuts-modal-close {
        color: #aaa;
        float: right;
        font-size: 28px;
        font-weight: bold;
      }

      .shortcuts-modal-close:hover,
      .shortcuts-modal-close:focus {
        color: black;
        text-decoration: none;
        cursor: pointer;
      }
      .shortcuts-modal h2 {
        margin-top: 0;
        border-bottom: 1px solid #eee;
        padding-bottom: 10px;
      }
      .shortcuts-modal ul {
        list-style-type: none;
        padding: 0;
      }
      .shortcuts-modal li {
        padding: 8px 0;
        border-bottom: 1px solid #f0f0f0;
        display: flex; /* Flexboxを使用して要素を配置 */
        justify-content: space-between; /* 両端に配置 */
        align-items: center; /* 中央揃え（垂直方向） */
      }
      .shortcuts-modal li:last-child {
        border-bottom: none;
      }
      .shortcuts-modal kbd {
        background-color: #eee;
        border-radius: 3px;
        border: 1px solid #b4b4b4;
        box-shadow: 0 1px 1px rgba(0, 0, 0, 0.2),
          0 2px 0 0 rgba(255, 255, 255, 0.7) inset;
        color: #333;
        display: inline-block;
        font-size: 0.85em;
        font-weight: 700;
        line-height: 1;
        padding: 2px 4px;
        white-space: nowrap;
        margin: 0 2px; /* kbd要素間のマージン調整 */
      }
      .shortcuts-modal .shortcut-keys {
        display: flex; /* キーの組み合わせを横並びにする */
        align-items: center;
      }

      /* START: 折りたたみタスク展開ボタンのスタイル変更 */
      .djs-overlay-drilldown button.bjs-drilldown {
        background-color: #007bff; /* 青色の背景 */
        border: 1px solid #007bff; /* 青色の枠線 */
        border-radius: 4px; /* 角丸 */
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1); /* 軽い影 */
        color: white; /* アイコンの色を白に */
        padding: 4px; /* アイコン周りの余白を調整 */
        width: 28px; /* ボタンの幅 */
        height: 28px; /* ボタンの高さ */
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .djs-overlay-drilldown button.bjs-drilldown:hover {
        background-color: #0056b3; /* ホバー時の背景色を少し濃く */
        border-color: #0056b3;
      }

      .djs-overlay-drilldown button.bjs-drilldown svg {
        fill: white; /* SVGアイコンの色を白に */
        width: 16px; /* アイコンのサイズ調整 */
        height: 16px; /* アイコンのサイズ調整 */
      }
      div.djs-overlay.djs-overlay-drilldown button.bjs-drilldown {
        padding: 0;
      }
      /* END: 折りたたみタスク展開ボタンのスタイル変更 */
    </style>
  </head>
  <body>
    <div id="bpmn-container"></div>

    <div class="floating-buttons">
      <button id="btn-import-bpmn" class="btn" title="BPMN読込 (.bpmn)">
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="20"
          height="20"
          fill="currentColor"
          class="bi bi-folder2-open"
          viewBox="0 0 16 16"
        >
          <path
            d="M1 3.5A1.5 1.5 0 0 1 2.5 2h2.764c.973 0 1.942.372 2.684 1.054L10.5 5.5H14.5A1.5 1.5 0 0 1 16 7v5.5a1.5 1.5 0 0 1-1.5 1.5h-13A1.5 1.5 0 0 1 0 12.5V4.964A1.5 1.5 0 0 1 1 3.5zM2 6h12v-.5a.5.5 0 0 0-.5-.5H9.828a.5.5 0 0 1-.354-.146l-.943-.943A.5.5 0 0 0 8.172 4H2.5a.5.5 0 0 0-.5.5V6zm-1 7v-5.5A1.5 1.5 0 0 1 2.5 6h11A1.5 1.5 0 0 1 15 7.5V13a1 1 0 0 1-1 1H1.5a1 1 0 0 1-1-1z"
          />
        </svg>
      </button>
      <button id="btn-create-new" class="btn" title="新規作成">
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="20"
          height="20"
          fill="currentColor"
          class="bi bi-plus-lg"
          viewBox="0 0 16 16"
        >
          <path
            fill-rule="evenodd"
            d="M8 2a.5.5 0 0 1 .5.5v5h5a.5.5 0 0 1 0 1h-5v5a.5.5 0 0 1-1 0v-5h-5a.5.5 0 0 1 0-1h5v-5A.5.5 0 0 1 8 2Z"
          />
        </svg>
      </button>
      <button id="btn-export-bpmn" class="btn" title="BPMN出力 (.bpmn)">
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="20"
          height="20"
          fill="currentColor"
          class="bi bi-download"
          viewBox="0 0 16 16"
        >
          <path
            d="M.5 9.9a.5.5 0 0 1 .5.5v2.5a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-2.5a.5.5 0 0 1 1 0v2.5a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2v-2.5a.5.5 0 0 1 .5-.5z"
          />
          <path
            d="M7.646 11.854a.5.5 0 0 0 .708 0l3-3a.5.5 0 0 0-.708-.708L8.5 10.293V1.5a.5.5 0 0 0-1 0v8.793L5.354 8.146a.5.5 0 1 0-.708.708l3 3z"
          />
        </svg>
      </button>
      <button id="btn-show-svg" class="btn" title="SVG表示 (別タブ)">
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="20"
          height="20"
          fill="currentColor"
          class="bi bi-image"
          viewBox="0 0 16 16"
        >
          <path d="M6.002 5.5a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0z" />
          <path
            d="M2.002 1a2 2 0 0 0-2 2v10a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V3a2 2 0 0 0-2-2h-12zm12 1a1 1 0 0 1 1 1v6.5l-3.777-1.947a.5.5 0 0 0-.577.093l-3.71 3.71-2.66-1.772a.5.5 0 0 0-.63.062L1.002 12V3a1 1 0 0 1 1-1h12z"
          />
        </svg>
      </button>
      <button id="btn-export-svg" class="btn" title="SVGエクスポート (.svg)">
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="20"
          height="20"
          fill="currentColor"
          class="bi bi-file-earmark-image"
          viewBox="0 0 16 16"
        >
          <path d="M6.502 7a1.5 1.5 0 1 0 0-3 1.5 1.5 0 0 0 0 3z" />
          <path
            d="M14 14a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V2a2 2 0 0 1 2-2h5.5L14 4.5V14zM4 1a1 1 0 0 0-1 1v10l2.224-2.224a.5.5 0 0 1 .61-.075L8 11l2.157-3.02a.5.5 0 0 1 .76-.063L13 10V4.5h-2A1.5 1.5 0 0 1 9.5 3V1H4z"
          />
        </svg>
      </button>
      <button
        id="btn-show-shortcuts"
        class="btn"
        title="キーボードショートカット"
      >
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="20"
          height="20"
          fill="currentColor"
          class="bi bi-keyboard"
          viewBox="0 0 16 16"
        >
          <path
            d="M14 5a1 1 0 0 1 1 1v5a1 1 0 0 1-1 1H2a1 1 0 0 1-1-1V6a1 1 0 0 1 1-1h12zM2 4a2 2 0 0 0-2 2v5a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2H2z"
          />
          <path
            d="M13 10.25a.25.25 0 0 1 .25-.25h.5a.25.25 0 0 1 .25.25v.5a.25.25 0 0 1-.25.25h-.5a.25.25 0 0 1-.25-.25v-.5zm0-2a.25.25 0 0 1 .25-.25h.5a.25.25 0 0 1 .25.25v.5a.25.25 0 0 1-.25.25h-.5a.25.25 0 0 1-.25-.25v-.5zm-2 2a.25.25 0 0 1 .25-.25h.5a.25.25 0 0 1 .25.25v.5a.25.25 0 0 1-.25.25h-.5a.25.25 0 0 1-.25-.25v-.5zm0-2a.25.25 0 0 1 .25-.25h.5a.25.25 0 0 1 .25.25v.5a.25.25 0 0 1-.25.25h-.5a.25.25 0 0 1-.25-.25v-.5zm-2 2a.25.25 0 0 1 .25-.25h.5a.25.25 0 0 1 .25.25v.5a.25.25 0 0 1-.25.25h-.5a.25.25 0 0 1-.25-.25v-.5zm0-2a.25.25 0 0 1 .25-.25h.5a.25.25 0 0 1 .25.25v.5a.25.25 0 0 1-.25.25h-.5a.25.25 0 0 1-.25-.25v-.5zm-2 2a.25.25 0 0 1 .25-.25h.5a.25.25 0 0 1 .25.25v.5a.25.25 0 0 1-.25.25h-.5a.25.25 0 0 1-.25-.25v-.5zm0-2a.25.25 0 0 1 .25-.25h.5a.25.25 0 0 1 .25.25v.5a.25.25 0 0 1-.25.25h-.5a.25.25 0 0 1-.25-.25v-.5zm-2 2a.25.25 0 0 1 .25-.25h.5a.25.25 0 0 1 .25.25v.5a.25.25 0 0 1-.25.25h-.5a.25.25 0 0 1-.25-.25v-.5zm0-2a.25.25 0 0 1 .25-.25h.5a.25.25 0 0 1 .25.25v.5a.25.25 0 0 1-.25.25h-.5a.25.25 0 0 1-.25-.25v-.5zm-2 2a.25.25 0 0 1 .25-.25h1.5a.25.25 0 0 1 .25.25v.5a.25.25 0 0 1-.25.25h-1.5a.25.25 0 0 1-.25-.25v-.5zm0-2a.25.25 0 0 1 .25-.25h.5a.25.25 0 0 1 .25.25v.5a.25.25 0 0 1-.25.25h-.5a.25.25 0 0 1-.25-.25v-.5zM2.5 7.75a.25.25 0 0 1 .25-.25h.5a.25.25 0 0 1 .25.25v.5a.25.25 0 0 1-.25.25h-.5a.25.25 0 0 1-.25-.25v-.5zm0 2a.25.25 0 0 1 .25-.25h.5a.25.25 0 0 1 .25.25v.5a.25.25 0 0 1-.25.25h-.5a.25.25 0 0 1-.25-.25v-.5z"
          />
        </svg>
      </button>
      <button
        id="btn-learn-bpmn"
        class="btn"
        title="BPMN作成ハンドブックを開く"
      >
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="20"
          height="20"
          fill="currentColor"
          class="bi bi-question-circle"
          viewBox="0 0 16 16"
        >
          <path
            d="M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"
          />
          <path
            d="M5.255 5.786a.237.237 0 0 0 .241.247h.825c.138 0 .248-.113.266-.25.09-.656.54-1.134 1.342-1.134.686 0 1.314.343 1.314 1.168 0 .635-.374.927-.965 1.371-.673.489-1.206 1.06-1.168 1.987l.003.217a.25.25 0 0 0 .25.246h.811a.25.25 0 0 0 .25-.25v-.105c0-.718.273-.927 1.01-1.486.609-.463 1.244-.977 1.244-2.056 0-1.511-1.276-2.241-2.673-2.241-1.267 0-2.655.59-2.75 2.286zm1.557 5.763c0 .533.425.927 1.01.927.609 0 1.028-.394 1.028-.927 0-.552-.42-.94-1.029-.94-.584 0-1.009.388-1.009.94z"
          />
        </svg>
      </button>
      <input
        type="file"
        id="file-input-bpmn"
        style="display: none"
        accept=".bpmn, .xml"
      />
    </div>

    <div id="error-message">
      <span id="error-text"></span>
      <a class="close-error" id="close-error-btn">&times;</a>
    </div>

    <div id="shortcuts-modal" class="shortcuts-modal">
      <div class="shortcuts-modal-content">
        <span class="shortcuts-modal-close" id="close-shortcuts-modal-btn"
          >&times;</span
        >
        <h2 style="font-size: 1.1rem; font-weight: bold">
          キーボードショートカット
        </h2>
        <ul>
          <li></li>
          <li>
            <span>BPMNファイルを保存</span
            ><span class="shortcut-keys"><kbd>Ctrl</kbd> + <kbd>S</kbd></span>
          </li>
          <li>
            <span>元に戻す</span
            ><span class="shortcut-keys"><kbd>Ctrl</kbd> + <kbd>Z</kbd></span>
          </li>
          <li>
            <span>やり直す</span
            ><span class="shortcut-keys"><kbd>Ctrl</kbd> + <kbd>X</kbd></span>
          </li>
          <li>
            <span>すべて選択</span
            ><span class="shortcut-keys"><kbd>Ctrl</kbd> + <kbd>A</kbd></span>
          </li>
          <li>
            <span>ズーム</span
            ><span class="shortcut-keys"
              ><kbd>Ctrl</kbd> + <kbd>スクロール</kbd></span
            >
          </li>
          <li>
            <span>要素の文字編集</span
            ><span class="shortcut-keys"><kbd>E</kbd></span>
          </li>
          <li>
            <span>ハンドツール</span
            ><span class="shortcut-keys"><kbd>H</kbd></span>
          </li>
          <li>
            <span>投げ縄ツール</span
            ><span class="shortcut-keys"><kbd>L</kbd></span>
          </li>
          <li>
            <span>スペースツール</span
            ><span class="shortcut-keys"><kbd>S</kbd></span>
          </li>
        </ul>
      </div>
    </div>

    <script src="./lib/bpmn-modeler.development.js"></script>

    <script type="module">
      // 日本語翻訳データを直接定義
      const japaneseTranslations = {
        "Activate create/remove space tool":
          "スペースの作成/削除ツールを有効化",
        "Activate global connect tool": "グローバル接続ツールを有効化",
        "Activate hand tool": "ハンドツールを有効化",
        "Activate lasso tool": "投げ縄（矩形）選択ツールを有効化",
        "Ad-hoc sub-process": "アドホックサブプロセス",
        "Ad-hoc sub-process (collapsed)":
          "アドホックサブプロセス（折りたたみ）",
        "Ad-hoc sub-process (expanded)": "アドホックサブプロセス（展開）",
        "Add lane above": "上にレーンを追加",
        "Add lane below": "下にレーンを追加",
        "Add text annotation": "注釈を追加",
        "Align elements": "要素の配置",
        "Align elements bottom": "要素を下に揃える",
        "Align elements center": "要素を左右中央に揃える",
        "Align elements left": "要素を左に揃える",
        "Align elements middle": "要素を上下中央に揃える",
        "Align elements right": "要素を右に揃える",
        "Align elements top": "要素を上に揃える",
        "Append compensation activity": "補償アクティビティを追加",
        "Append conditional intermediate catch event":
          "条件付き中間キャッチイベントを追加",
        "Append end event": "終了イベントを追加",
        "Append gateway": "ゲートウェイを追加",
        "Append intermediate/boundary event": "中間/境界イベントを追加",
        "Append message intermediate catch event":
          "メッセージ中間キャッチイベントを追加",
        "Append receive task": "受信タスクを追加",
        "Append signal intermediate catch event":
          "シグナル中間キャッチイベントを追加",
        "Append task": "タスクを追加",
        "Append timer intermediate catch event":
          "タイマー中間キャッチイベントを追加",
        "Business rule task": "ビジネスルールタスク",
        "Call activity": "コールアクティビティ",
        "Cancel boundary event": "キャンセル境界イベント",
        "Cancel end event": "キャンセル終了イベント",
        "Change element": "要素を変更",
        Collection: "コレクション",
        "Compensation boundary event": "補償境界イベント",
        "Compensation end event": "補償終了イベント",
        "Compensation intermediate throw event": "補償中間スローイベント",
        "Compensation start event": "補償開始イベント",
        "Complex gateway": "複合ゲートウェイ",
        "Conditional boundary event": "条件付き境界イベント",
        "Conditional boundary event (non-interrupting)":
          "条件付き境界イベント（中断なし）",
        "Conditional flow": "条件付きフロー",
        "Conditional intermediate catch event": "条件付き中間キャッチイベント",
        "Conditional start event": "条件付き開始イベント",
        "Conditional start event (non-interrupting)":
          "条件付き開始イベント（中断なし）",
        "Connect to other element": "他の要素に接続",
        "Connect using association": "関連付けを使用して接続",
        "Connect using data input association":
          "データ入力関連付けを使用して接続",
        "Create data object reference": "データオブジェクト参照を作成",
        "Create data store reference": "データストア参照を作成",
        "Create end event": "終了イベントを作成",
        "Create expanded sub-process": "展開されたサブプロセスを作成",
        "Create gateway": "ゲートウェイを作成",
        "Create group": "グループを作成",
        "Create intermediate/boundary event": "中間/境界イベントを追加",
        "Create pool/participant": "プール/参加者を作成",
        "Create start event": "開始イベントを作成",
        "Create task": "タスクを作成",
        "Data object reference": "データオブジェクト参照",
        "Data store reference": "データストア参照",
        "Default flow": "デフォルトフロー",
        Delete: "削除",
        "Distribute elements horizontally": "要素を水平に配置",
        "Distribute elements vertically": "要素を垂直に配置",
        "Divide into three lanes": "3つのレーンに分割",
        "Divide into two lanes": "2つのレーンに分割",
        "Empty pool/participant": "プール/参加者を空にする",
        "Empty pool/participant (removes content)":
          "プール/参加者を空にする（内容は削除）",
        "End event": "終了イベント",
        "Error boundary event": "エラー境界イベント",
        "Error end event": "エラー終了イベント",
        "Error start event": "エラー開始イベント",
        "Escalation boundary event": "エスカレーション境界イベント",
        "Escalation boundary event (non-interrupting)":
          "エスカレーション境界イベント（中断なし）",
        "Escalation end event": "エスカレーション終了イベント",
        "Escalation intermediate throw event":
          "エスカレーション中間スローイベント",
        "Escalation start event": "エスカレーション開始イベント",
        "Escalation start event (non-interrupting)":
          "エスカレーション開始イベント（中断なし）",
        "Event sub-process": "イベントサブプロセス",
        "Event-based gateway": "イベントベースのゲートウェイ",
        "Exclusive gateway": "排他ゲートウェイ",
        "Inclusive gateway": "包含ゲートウェイ",
        "Intermediate throw event": "中間スローイベント",
        "Link intermediate catch event": "リンク中間キャッチイベント",
        "Link intermediate throw event": "リンク中間スローイベント",
        Loop: "ループ",
        "Manual task": "手動タスク",
        "Message boundary event": "メッセージ境界イベント",
        "Message boundary event (non-interrupting)":
          "メッセージ境界イベント（中断なし）",
        "Message end event": "メッセージ終了イベント",
        "Message intermediate catch event": "メッセージ中間キャッチイベント",
        "Message intermediate throw event": "メッセージ中間スローイベント",
        "Message start event": "メッセージ開始イベント",
        "Message start event (non-interrupting)":
          "メッセージ開始イベント（中断なし）",
        "Open {element}": "{element} を開く",
        "Parallel gateway": "並列ゲートウェイ",
        "Parallel multi-instance": "並列マルチインスタンス",
        "Participant multiplicity": "Participant multiplicity",
        "Receive task": "受信タスク",
        "Script task": "スクリプトタスク",
        "Search in diagram": "図内を検索",
        "Send task": "送信タスク",
        "Sequence flow": "シーケンスフロー",
        "Sequential multi-instance": "連続マルチインスタンス",
        "Service task": "サービスタスク",
        "Signal boundary event": "シグナル境界イベント",
        "Signal boundary event (non-interrupting)":
          "シグナル境界イベント（中断なし）",
        "Signal end event": "シグナル終了イベント",
        "Signal intermediate catch event": "シグナル中間キャッチイベント",
        "Signal intermediate throw event": "シグナル中間スローイベント",
        "Signal start event": "シグナル開始イベント",
        "Signal start event (non-interrupting)":
          "シグナル開始イベント（中断なし）",
        "Start event": "開始イベント",
        "Sub-process": "サブプロセス",
        "Sub-process (collapsed)": "サブプロセス（折りたたみ）",
        "Sub-process (expanded)": "サブプロセス（展開）",
        Task: "タスク",
        "Terminate end event": "終了イベントの終了",
        "Timer boundary event": "タイマー境界イベント",
        "Timer boundary event (non-interrupting)":
          "タイマー境界イベント（中断なし）",
        "Timer intermediate catch event": "タイマー中間キャッチイベント",
        "Timer start event": "タイマー開始イベント",
        "Timer start event (non-interrupting)":
          "タイマー開始イベント（中断なし）",
        "Toggle non-interrupting": "中断なしに切り替え",
        Transaction: "トランザクション",
        "User task": "ユーザータスク",
        "flow elements must be children of pools/participants":
          "フロー要素はプール/参加者の子でなければなりません",
      };

      const initialDiagramXML = `<?xml version="1.0" encoding="UTF-8"?>
<bpmn:definitions xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:bpmn="http://www.omg.org/spec/BPMN/20100524/MODEL" xmlns:bpmndi="http://www.omg.org/spec/BPMN/20100524/DI" xmlns:dc="http://www.omg.org/spec/DD/20100524/DC" targetNamespace="http://bpmn.io/schema/bpmn" id="Definitions_1" name="Default Process">
  <bpmn:process id="Process_1" name="Top" isExecutable="false">
    <bpmn:startEvent id="StartEvent_1" name="開始"/>
  </bpmn:process>
  <bpmndi:BPMNDiagram id="BPMNDiagram_1">
    <bpmndi:BPMNPlane id="BPMNPlane_1" bpmnElement="Process_1">
      <bpmndi:BPMNShape id="_BPMNShape_StartEvent_2" bpmnElement="StartEvent_1">
        <dc:Bounds height="36.0" width="36.0" x="173.0" y="102.0"/>
      </bpmndi:BPMNShape>
    </bpmndi:BPMNPlane>
  </bpmndi:BPMNDiagram>
</bpmn:definitions>`;

      let modeler;
      let djsContainerObserver;
      let breadcrumbsShownProcessed = false;

      const bpmnContainer = document.getElementById("bpmn-container");
      const btnCreateNew = document.getElementById("btn-create-new");
      const btnExportBpmn = document.getElementById("btn-export-bpmn");
      const btnImportBpmn = document.getElementById("btn-import-bpmn");
      const fileInputBpmn = document.getElementById("file-input-bpmn");
      const btnShowSvg = document.getElementById("btn-show-svg");
      const btnExportSvg = document.getElementById("btn-export-svg");
      const btnLearnBpmn = document.getElementById("btn-learn-bpmn");
      const btnShowShortcuts = document.getElementById("btn-show-shortcuts");
      const shortcutsModal = document.getElementById("shortcuts-modal");
      const closeShortcutsModalBtn = document.getElementById(
        "close-shortcuts-modal-btn"
      );

      const errorMessageDiv = document.getElementById("error-message");
      const errorTextSpan = document.getElementById("error-text");
      const closeErrorBtn = document.getElementById("close-error-btn");

      function showError(message) {
        errorTextSpan.textContent = message;
        errorMessageDiv.style.display = "block";
        console.error(message);
      }

      function clearError() {
        errorMessageDiv.style.display = "none";
        errorTextSpan.textContent = "";
      }
      closeErrorBtn.onclick = clearError;

      function getCurrentDateString() {
        const date = new Date();
        const year = date.getFullYear();
        const month = (date.getMonth() + 1).toString().padStart(2, "0");
        const day = date.getDate().toString().padStart(2, "0");
        return `${year}-${month}-${day}`;
      }

      function downloadFile(filename, data, type) {
        const blob = new Blob([data], { type });
        const link = document.createElement("a");
        link.href = URL.createObjectURL(blob);
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(link.href);
      }

      function fitViewport() {
        if (!modeler) return;
        const canvas = modeler.get("canvas");
        if (canvas) {
          try {
            if (canvas.getRootElement()) {
              canvas.zoom("fit-viewport", "auto");
              console.log(
                "ビューポートをフィットさせました。対象:",
                canvas.getRootElement().id
              );
            } else {
              console.warn(
                "ルート要素が見つからないため、ビューポートのフィットをスキップしました。"
              );
            }
          } catch (e) {
            console.error("ビューポートフィットに失敗:", e);
            showError(`ビューの調整に失敗しました: ${e.message || e}`);
          }
        }
      }

      function fitViewportWithDelay(delay = 250) {
        console.log(`ビューポート調整を ${delay}ms 遅延実行します。`);
        setTimeout(fitViewport, delay);
      }

      async function importBPMN(xml) {
        clearError();
        if (!modeler) return;

        if (
          !window.confirm(
            "現在のキャンバスをクリアしてファイルを開いてもよろしいですか？"
          )
        ) {
          console.log(
            "ファイルインポート（ドラッグ＆ドロップ）がキャンセルされました。"
          );
          return;
        }

        try {
          await modeler.importXML(xml);
          console.log("BPMN XMLが正常にインポートされました。");
          fitViewport();
          breadcrumbsShownProcessed = false;
          updateBreadcrumbsVisibility();
        } catch (err) {
          showError(`BPMNファイルのインポートに失敗: ${err.message || err}`);
        }
      }

      function customTranslate(template, replacements) {
        replacements = replacements || {};
        const translatedTemplate = japaneseTranslations[template] || template;
        return translatedTemplate.replace(/{([^}]+)}/g, function (_, key) {
          const value = replacements[key];
          return value !== undefined ? value : "{" + key + "}";
        });
      }

      const translateModule = {
        translate: ["value", customTranslate],
      };

      function updateBreadcrumbsVisibility() {
        const breadcrumbsULElement =
          bpmnContainer.querySelector("ul.bjs-breadcrumbs");
        if (breadcrumbsULElement) {
          const listItems = breadcrumbsULElement.querySelectorAll("li");
          if (listItems.length > 1) {
            breadcrumbsULElement.style.display = "block";
          } else {
            breadcrumbsULElement.style.display = "none";
          }
        }
      }

      function openShortcutsModal() {
        if (shortcutsModal) shortcutsModal.style.display = "block";
      }

      function closeShortcutsModal() {
        if (shortcutsModal) shortcutsModal.style.display = "none";
      }

      function initializeModeler() {
        clearError();
        modeler = new BpmnJS({
          container: bpmnContainer,
          keyboard: { bindTo: window },
          additionalModules: [translateModule],
        });

        // START: 変更箇所 (ここから)
        const eventBus = modeler.get("eventBus");
        const elementRegistry = modeler.get("elementRegistry");
        const overlays = modeler.get("overlays");

        // ドリルダウンオーバーレイの表示状態を更新する関数
        function updateDrilldownOverlayVisibility(element, selectedElementId) {
          // 'drilldown' タイプのオーバーレイを取得
          const drilldownOverlays = overlays.get({
            element: element.id,
            type: "drilldown",
          });

          if (drilldownOverlays && drilldownOverlays.length > 0) {
            drilldownOverlays.forEach((overlay) => {
              let shouldShow = false;
              // 要素が選択されており、かつそれが現在の要素である場合
              if (selectedElementId === element.id) {
                const bo = element.businessObject;
                // サブプロセスまたはコールアクティビティであるかを確認
                // bpmn-js は通常、ドリルダウン可能な要素にのみこのオーバーレイを追加します
                if (
                  bo &&
                  (bo.$instanceOf("bpmn:SubProcess") ||
                    bo.$instanceOf("bpmn:CallActivity"))
                ) {
                  shouldShow = true;
                }
              }

              // overlay.html はオーバーレイのルート <div> 要素を指します
              if (overlay.html) {
                overlay.html.style.display = shouldShow ? "block" : "none";
              }
            });
          }
        }

        // 選択変更イベントの処理
        eventBus.on("selection.changed", function (event) {
          const newSelection = event.newSelection;
          const oldSelection = event.oldSelection;
          const selectedElement =
            newSelection.length === 1 ? newSelection[0] : null;
          const selectedElementId = selectedElement ? selectedElement.id : null;

          // 以前選択されていた要素のオーバーレイを更新（非表示にする）
          if (
            oldSelection.length === 1 &&
            oldSelection[0] !== selectedElement
          ) {
            updateDrilldownOverlayVisibility(
              oldSelection[0],
              selectedElementId
            );
          }

          // 新しく選択された要素のオーバーレイを更新（表示する）
          if (selectedElement) {
            updateDrilldownOverlayVisibility(
              selectedElement,
              selectedElementId
            );
          } else {
            // 何も選択されていない、または複数選択されている場合、
            // すべてのドリルダウンオーバーレイを非表示にする (念のため)
            elementRegistry.forEach(function (element) {
              updateDrilldownOverlayVisibility(element, null);
            });
          }
        });

        // 初期状態および図の変更時のオーバーレイ表示を管理する関数
        function manageAllDrilldownOverlaysVisibility() {
          const currentSelection = modeler.get("selection").get();
          const selectedElement =
            currentSelection.length === 1 ? currentSelection[0] : null;
          const selectedElementId = selectedElement ? selectedElement.id : null;

          elementRegistry.forEach(function (element) {
            updateDrilldownOverlayVisibility(element, selectedElementId);
          });
        }

        // 図の読み込み完了後やコマンドスタック変更後にオーバーレイの表示状態を管理
        eventBus.on(["import.done", "commandStack.changed"], function () {
          // bpmn-js がオーバーレイを処理する時間を確保するために少し遅延させる
          setTimeout(manageAllDrilldownOverlaysVisibility, 0);
        });
        // END: 変更箇所 (ここまで)

        modeler
          .importXML(initialDiagramXML)
          .then(() => {
            console.log("初期ダイアグラムが正常に読み込まれました。");
            fitViewport();
            breadcrumbsShownProcessed = false;
            updateBreadcrumbsVisibility();
            // START: 変更箇所 - 初期表示のために manageAllDrilldownOverlaysVisibility を呼び出す
            setTimeout(manageAllDrilldownOverlaysVisibility, 0);
            // END: 変更箇所

            const canvasInternal = modeler.get("canvas");
            if (canvasInternal && canvasInternal._container) {
              const djsContainerElement = canvasInternal._container;
              djsContainerObserver = new MutationObserver((mutationsList) => {
                for (const mutation of mutationsList) {
                  if (
                    mutation.type === "attributes" &&
                    mutation.attributeName === "class"
                  ) {
                    const targetElement = mutation.target;
                    const classList = targetElement.classList;
                    if (classList.contains("bjs-breadcrumbs-shown")) {
                      if (!breadcrumbsShownProcessed) {
                        breadcrumbsShownProcessed = true;
                        updateBreadcrumbsVisibility();
                        fitViewportWithDelay();
                      }
                    } else {
                      if (breadcrumbsShownProcessed) {
                        breadcrumbsShownProcessed = false;
                        updateBreadcrumbsVisibility();
                      }
                    }
                  } else if (
                    mutation.type === "childList" &&
                    mutation.target.classList &&
                    mutation.target.classList.contains("bjs-breadcrumbs")
                  ) {
                    updateBreadcrumbsVisibility();
                  }
                }
              });
              djsContainerObserver.observe(djsContainerElement, {
                attributes: true,
                childList: true,
                subtree: true,
              });
            } else {
              console.warn("djs-containerの監視設定に失敗しました。");
            }
          })
          .catch((err) => {
            showError(
              `初期ダイアグラムの読み込みに失敗: ${err.message || err}`
            );
          });

        modeler.on("root.changed", (event) => {
          const currentRoot = event.element || event.newRoot || event.root;
          const oldRoot = event.oldRoot;

          if (currentRoot && typeof currentRoot.id !== "undefined") {
            console.log(
              "ルート要素が変更/更新されました: old=",
              oldRoot && typeof oldRoot.id !== "undefined"
                ? oldRoot.id
                : "undefined",
              "current=",
              currentRoot.id
            );
          } else if (currentRoot) {
            console.warn(
              "ルート要素が変更/更新されましたが、IDがありません:",
              currentRoot,
              "イベント詳細:",
              event
            );
          }

          breadcrumbsShownProcessed = false;
          updateBreadcrumbsVisibility();
          fitViewportWithDelay();
        });

        window.addEventListener("resize", function () {
          if (modeler) {
            const canvas = modeler.get("canvas");
            if (canvas) {
              canvas.resized();
              console.log(
                "ウィンドウリサイズイベント: canvas.resized() を呼び出しました。"
              );
            }
          }
        });

        const eventBusInstance = modeler.get("eventBus");
        if (eventBusInstance) {
          eventBusInstance.on("breadcrumbs.updated", function (event) {
            console.log(
              "パンくずリスト(モジュール)が更新されました。イベント:",
              event
            );
            updateBreadcrumbsVisibility();
            fitViewportWithDelay();
          });
        } else {
          console.warn(
            "eventBusが見つからず、breadcrumbs.updatedイベントを購読できません。"
          );
        }
      }

      btnCreateNew.addEventListener("click", async () => {
        clearError();
        if (!modeler) return;

        if (
          !window.confirm(
            "現在のキャンパスをクリアして新規作成してもよろしいですか？"
          )
        ) {
          console.log("新規作成がキャンセルされました。");
          return;
        }

        try {
          const newDiagramXML = initialDiagramXML
            .replace(/id="Process_1"/g, `id="Process_${new Date().getTime()}"`)
            .replace(/name="Top"/g, 'name="Top"')
            .replace(
              /id="StartEvent_1"/g,
              `id="StartEvent_${new Date().getTime()}"`
            )
            .replace(/name="開始"/g, 'name="開始"');
          await modeler.importXML(newDiagramXML);
          console.log("新しいダイアグラムが作成されました。");
          fitViewport();
          breadcrumbsShownProcessed = false;
          updateBreadcrumbsVisibility();
        } catch (err) {
          showError(`新規ダイアグラムの作成に失敗: ${err.message || err}`);
        }
      });

      btnExportBpmn.addEventListener("click", async () => {
        clearError();
        if (!modeler) return;
        try {
          const dateStr = getCurrentDateString();
          const defaultFilename = `${dateStr}_FlowCanvas.bpmn`;

          const filename = window.prompt(
            "BPMNファイル名を入力してください:",
            defaultFilename
          );
          if (filename === null) {
            console.log("BPMNエクスポートがキャンセルされました。");
            return;
          }
          if (filename.trim() === "") {
            showError("ファイル名が空です。");
            return;
          }
          const finalFilename = filename.endsWith(".bpmn")
            ? filename
            : filename + ".bpmn";

          const { xml } = await modeler.saveXML({ format: true });
          downloadFile(finalFilename, xml, "application/xml");
          console.log(
            `BPMN XMLが ${finalFilename} としてエクスポートされました。`
          );
        } catch (err) {
          showError(`BPMNのエクスポートに失敗: ${err.message || err}`);
        }
      });

      btnImportBpmn.addEventListener("click", () => {
        clearError();
        if (
          modeler.getDefinitions() &&
          modeler.getDefinitions().rootElements &&
          modeler.getDefinitions().rootElements.length > 0 &&
          !(
            modeler.getDefinitions().rootElements.length === 1 &&
            modeler.getDefinitions().rootElements[0].id === "Process_1" &&
            modeler.getDefinitions().rootElements[0].flowElements.length ===
              1 &&
            modeler.getDefinitions().rootElements[0].flowElements[0].id ===
              "StartEvent_1"
          )
        ) {
          if (
            !window.confirm(
              "現在のキャンパスをクリアしてファイルを開いてもよろしいですか？"
            )
          ) {
            console.log("ファイルインポート（ボタン）がキャンセルされました。");
            return;
          }
        }
        fileInputBpmn.click();
      });

      fileInputBpmn.addEventListener("change", (event) => {
        clearError();
        const file = event.target.files[0];
        if (file && modeler) {
          const reader = new FileReader();
          reader.onload = async (e) => {
            importBPMN(e.target.result);
          };
          reader.onerror = (e) => {
            showError(`ファイルの読み込みに失敗しました。`);
          };
          reader.readAsText(file);
        }
        event.target.value = "";
      });

      btnShowSvg.addEventListener("click", async () => {
        clearError();
        if (!modeler) return;
        try {
          const { svg } = await modeler.saveSVG();
          const canvas = modeler.get("canvas");
          const rootElement = canvas.getRootElement();
          const processName =
            (rootElement &&
              rootElement.businessObject &&
              rootElement.businessObject.name) ||
            "BPMN Diagram";

          let svgWithTitle = svg.replace(
            /<svg(.*?)>/,
            `<svg$1>\n  <title>${processName}</title>\n  <text x="10" y="20" font-family="Arial, sans-serif" font-size="16" fill="#333">${processName}</text>`
          );

          const svgWindow = window.open("");
          if (svgWindow) {
            svgWindow.document.write(svgWithTitle);
            svgWindow.document.title = "Flow Canvas";
            svgWindow.document.close();
            console.log("SVGが新しいタブに表示されました。");
          } else {
            showError(
              "新しいタブを開けませんでした。ポップアップブロッカーを確認してください。"
            );
          }
        } catch (err) {
          showError(`SVGの生成または表示に失敗: ${err.message || err}`);
        }
      });

      btnExportSvg.addEventListener("click", async () => {
        clearError();
        if (!modeler) return;
        try {
          const dateStr = getCurrentDateString();
          const defaultFilename = `${dateStr}_FlowCanvas.svg`;

          const filename = window.prompt(
            "SVGファイル名を入力してください:",
            defaultFilename
          );
          if (filename === null) {
            console.log("SVGエクスポートがキャンセルされました。");
            return;
          }
          if (filename.trim() === "") {
            showError("ファイル名が空です。");
            return;
          }
          const finalFilename = filename.endsWith(".svg")
            ? filename
            : filename + ".svg";

          const { svg } = await modeler.saveSVG();
          downloadFile(finalFilename, svg, "image/svg+xml");
          console.log(`SVGが ${finalFilename} としてエクスポートされました。`);
        } catch (err) {
          showError(`SVGのエクスポートに失敗: ${err.message || err}`);
        }
      });

      btnLearnBpmn.addEventListener("click", () => {
        window.open("learn-bpmn.html", "_blank");
      });

      if (btnShowShortcuts) {
        btnShowShortcuts.addEventListener("click", openShortcutsModal);
      }
      if (closeShortcutsModalBtn) {
        closeShortcutsModalBtn.addEventListener("click", closeShortcutsModal);
      }

      if (shortcutsModal) {
        window.addEventListener("click", function (event) {
          if (event.target == shortcutsModal) {
            closeShortcutsModal();
          }
        });
      }

      document.addEventListener("keydown", function (event) {
        // Ctrl+Shift+H: ショートカットモーダル表示
        if (
          event.ctrlKey &&
          event.shiftKey &&
          (event.key === "h" || event.key === "H")
        ) {
          // 大文字Hも考慮
          event.preventDefault();
          openShortcutsModal();
        }
        // Ctrl+S: BPMNファイル保存
        if (event.ctrlKey && (event.key === "s" || event.key === "S")) {
          event.preventDefault();
          if (btnExportBpmn) {
            btnExportBpmn.click(); // 保存ボタンのクリックイベントを発火
          }
        }
        // Ctrl+X: やり直し
        if (event.ctrlKey && (event.key === "x" || event.key === "X")) {
          event.preventDefault();
          if (modeler) {
            const commandStack = modeler.get("commandStack");
            if (commandStack && commandStack.canRedo()) {
              commandStack.redo();
              console.log("やり直しを実行しました。");
            } else {
              console.log("やり直し可能な操作がありません。");
            }
          }
        }
        // Ctrl+Z: 元に戻す (bpmn-jsのデフォルトの挙動)
        if (
          event.ctrlKey &&
          !event.shiftKey &&
          (event.key === "z" || event.key === "Z")
        ) {
          // bpmn-jsがデフォルトで処理するため、ここでは何もしない
          console.log("元に戻すを実行しました。");
        }
      });

      const dropContainer = document.getElementById("bpmn-container");

      dropContainer.addEventListener("dragover", function (event) {
        event.preventDefault();
        event.dataTransfer.dropEffect = "copy";
        dropContainer.classList.add("drop-active");
        console.log("dragover event");
      });

      dropContainer.addEventListener("dragleave", function (event) {
        dropContainer.classList.remove("drop-active");
        console.log("dragleave event");
      });

      dropContainer.addEventListener("drop", function (event) {
        event.preventDefault();
        dropContainer.classList.remove("drop-active");
        clearError();
        console.log("drop event");

        const files = event.dataTransfer.files;

        if (files.length === 1) {
          const file = files[0];
          if (file.name.endsWith(".bpmn") || file.name.endsWith(".xml")) {
            if (modeler) {
              const reader = new FileReader();
              reader.onload = async function (e) {
                importBPMN(e.target.result);
              };
              reader.onerror = function (e) {
                showError("ファイルの読み込みに失敗しました。");
              };
              reader.readAsText(file);
            }
          } else {
            showError(
              "BPMNファイル(.bpmn または .xml)をドロップしてください。"
            );
          }
        } else {
          showError("ファイルを1つだけドロップしてください。");
        }
      });

      document.addEventListener("DOMContentLoaded", initializeModeler);

      window.addEventListener("beforeunload", () => {
        if (djsContainerObserver) {
          djsContainerObserver.disconnect();
          console.log("djs-containerの監視を停止しました。");
        }
      });
    </script>
  </body>
</html>
